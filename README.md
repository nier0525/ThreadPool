# Mutex 성능
  
보통 스레드 간 동기화를 하기 위해서 Mutex 혹은 CriticalSection 등을 이용한다.  
이 기능을 배웠을 때 아무 곳이나 생각없이 막 가져다 쓰면 성능저하를 일으킬 수 있다는 교수님의 말이 떠올랐다.  
이에 얼마나 성능어 저하될까? 라는 의구심이 들어서 간단하게 몇몇 테스트를 해보았고 결과는 가히 충격적이었다..  
  
### Mutex 를 사용하지 않은 싱글 스레드 일 경우  
  
![5](https://user-images.githubusercontent.com/63215359/106782350-65d7de80-668d-11eb-8349-f3bcaf421557.PNG)  
  
비교를 위해 우선 Mutex 를 사용하지 않고 싱글 스레드로 돌린 결과이다.  
이제 멀티 스레드를 사용한다면 적어도 위 결과보다는 좋은 결과가 나와야 비로서 멀티 스레드의 사용 의의가 있을 것이다.  
  
### 첫번째 사례    
  
우선 최악의 사례가 무엇일까? 라고 생각하면서 Mutex 를 사용하였고 그 결과는..  
  
![1](https://user-images.githubusercontent.com/63215359/106781723-b4d14400-668c-11eb-813f-24adeda09aaa.PNG)  
  
스레드를 여러개 사용한 의미는 고사하고 하나만 사용한 것만도 못한 결과가 나와버렸다..  
이 결과만으로 나는 진짜 모르고 막 쓰다가 큰일난다는 교훈을 얻을 수 있었다.  
  
### 두번째 사례  
  
하나하나 검사하는 게 아니라 반복문 시작하기 전에 Look 을 걸고 반복문이 끝나면 Look 을 푸는 식으로 해보았다.  
  
![2](https://user-images.githubusercontent.com/63215359/106783544-c3b8f600-668e-11eb-847f-ab2f705d273c.PNG)  
  
확실히 첫번째에 비교하면 압도적으로 성능이 향상되었다..만 싱글 스레드랑 멀티 스레드일 때 성능 차이가 거의 없다..  
이러면 그냥 싱글 스레드를 사용하나 멀티 스레드를 사용하나 똑같은 수준이다.  
  
### 세번째 사례  
  
대체 어떻게 멀티 스레드의 장점을 살릴 수 있을까.. 생각하던 중에 스레드 함수 내에 지역 변수는 스레드끼리 공유하지 않는다는 게 생각이났다.  
그럼 이 지역변수를 반복문으로 값을 구하고 이 값을 sum 에 더할 때만 Look 을 걸어주면 어떨까?  
  
![3](https://user-images.githubusercontent.com/63215359/106784203-6a9d9200-668f-11eb-848b-185cf27692e1.PNG)  
  
그랬더니 드디어 유의미한 결과가 나왔다.  
어째서 이런 차이를 보이는걸까?  
가장 근본적인 건 Look 을 걸면 해제할 때까지 해당 스레드 외에는 작업을 할 수 없기 때문에 이런 결과가 나온 것이라 생각한다.  
그렇다면 아마 첫번째가 미쳐버린 성능 저하를 보였던 것은 셀 수 없이 많은 Look 을 걸고 풀기를 반복했기 때문에 다른 스레드들도 셀 수 없이 제동이 걸려서 그랬을 것이다.  
두번째는 반복문이 끝날 때까지 다른 스레드들이 작업을 하지 못했기 때문에 싱글 스레드와 성능차이가 미미했고,  
마지막은 지역변수를 이용해 반복문을 다 돈 후에 sum 에 더할 때만 Look 을 걸었기 때문에 다른 스레드들도 반복문을 돌 수 있어 비로소 유의미한 결과가 나온 것이다.  
  
확신할 수 없는 것은 아직 내가 이거 정답! 이라고 대답할 정도로 실력이 있는 게 아니라서 어디까지나 추측일 뿐이지만.. 결과가 엄청난 차이를 보였다는 것은 틀림 없다.  
  
  
  
  
# 스레드 풀과 멀티 스레드의 성능 차이 테스트  
  
기본적으로 스레드 풀과 멀티 스레드의 차이는 생성과 소멸의 비용이고 풀링이라는 기법은 싱글톤과 더불어 이미 널리 알려진 기법이었기 때문에 쉽게 이해할 수 있었다.  
그래서 문득 " 스레드 풀이랑 멀티 스레드 성능이 많이 차이가 나나? " 라는 의문이 들어 테스트를 해보았다.  
스레드 풀은 아주 간단하게 이벤트를 이용해서 구현했다.  
물론 올바르게 구현한 건 아니지만 최소한 생성,소멸 비용이 없게끔 구현하였다.  
그리고 아래가 약 5 번 정도 실행하여 성능을 대조한 결과이다.  
  
### 1  
  
![1](https://user-images.githubusercontent.com/63215359/106786398-d97bea80-6691-11eb-9a61-cc258cd4413f.PNG)  
  
### 2  
  
![2](https://user-images.githubusercontent.com/63215359/106786452-e7ca0680-6691-11eb-95f9-717aa35402b6.PNG)  
  
### 3  
  
![3](https://user-images.githubusercontent.com/63215359/106786490-f0bad800-6691-11eb-9628-e023597e9fde.PNG)  
  
### 4  
  
![4](https://user-images.githubusercontent.com/63215359/106786533-fadcd680-6691-11eb-880e-3a5242584534.PNG)  
  
### 5  
  
![5](https://user-images.githubusercontent.com/63215359/106786560-04fed500-6692-11eb-9fdf-7226b6f7e0d5.PNG)  
  
  
스레드 수에 비례해서 스레드 풀의 성능이 확실히 더 좋은 결과를 보였다.  
비록 그 차이가 적게 느껴질수도 있지만 위에서도 말했듯 올바른 스레드 풀 설계가 아닐 가능성이 높고 그걸 감안하면 이 성능 차이는 유의미하다고 생각이 든다.  
더욱 확실히 그 차이를 알려면 더 로우하게 알아 볼 필요가 있을 것 같다.  
  
